#!/usr/bin/env python
##
## Author(s):
##  - Dimitri MEREJKOWSKY <yannicklm1337@gmail.com>
##  - Cedric GESTES <ctaf42@gmail.com>
##
## Original Implementation provided by Dimitri
##

"""
Quick script to replace stuff in files

"""

import sys
import os
import re
import random
import logging
import fnmatch

from optparse import OptionParser

COLORS = {
    "bold"    :  "\033[1m"  ,
    "clear"   :  "\033[0m"  ,
    "red"     :  "\033[31m" ,
    "green"   :  "\033[32m" ,
    "blue"    :  "\033[34m" ,
}

FILTER_OUT = (
    ".git"    ,
    ".svn"    ,
    "*.py[co]",
    "*.[oa]"  ,
    "*~"
)

__usage__ = """
replacer [options]  PATTERN REPL [files]

eg:
  replacer 'toto' 'titi'
  replacer '(.*)toto([0-9]{0,3})' '\1titi\2'
  replacer --filter .py 'toto' 'titi'

Files matching %s are discarded.
""" % (str(FILTER_OUT))

LOGGER = logging.getLogger("replacer")

def recurse_file(opts, directory, action):
    """
    Recusively go do the subdirectories of the directory,
    calling the action on each file

    """
    for f in os.listdir(directory):
        if opts.get("no_hidden") and f.startswith("."):
            LOGGER.info("filter hidden  : %s/%s", directory, f)
            continue
        filter_out = False
        if not opts.get("no_filter"):
            for fo in FILTER_OUT:
                if fnmatch.fnmatch(f, fo):
                    LOGGER.info("filter %s: %s/%s", fo, directory, f)
                    filter_out = True
                    break
        if filter_out:
            continue
        f = os.path.join(directory, f)
        if os.path.isdir(f):
            recurse_file(opts, f, action)
        if os.path.isfile(f):
            action(f)


def replace_in_file(opts, in_file, regexp, repl):
    """
    Perfoms re.sub(regexp, repl, line) for each line in
    in_file
    """
    in_fd = open(in_file, "r")
    in_lines = in_fd.readlines()
    in_fd.close()

    out_lines = in_lines[:]
    out_lines = [re.sub(regexp, repl, l) for l in in_lines]

    diff = False

    # See if there's a diff first:
    for (in_line, out_line) in zip(in_lines, out_lines):
        if in_line != out_line:
            diff = True

    if not diff:
        return

    if not opts.get("quiet"):
        print COLORS["bold"] + COLORS["blue"] + "patching: " + in_file + COLORS["clear"]
    if opts.get("go"):
        if opts.get("backup"):
            rand_int = random.randint(100,999)
            back_file = "%s-%i.back" % (in_file, rand_int)
            back_file_fd = open(back_file, "w")
            back_file_fd.writelines(in_lines)
            back_file_fd.close()
        out_fd = open(in_file, "w")
        out_fd.writelines(out_lines)
        out_fd.close()

    if opts.get("quiet"):
        return

    for (in_line, out_line) in zip(in_lines, out_lines):
        if in_line != out_line:
            in_line  = in_line.strip()
            out_line = out_line.strip()
            print COLORS["bold"] + COLORS["red"]   + "--" + in_line  + COLORS["clear"]
            print COLORS["bold"] + COLORS["green"] + "++" + out_line + COLORS["clear"]
            print


def main():
    """
    manages options when called from command line

    """
    option_parser = OptionParser(usage = __usage__)
    option_parser.add_option("--no-skip-hidden",
        action = "store_false", dest = "no_hidden",
        help = "Do not skip hidden files. Use this if you know what you are doing...")
    option_parser.add_option("--no-filter", action = "store_true", dest = "no_filter",
                             help = "Do not skip files that match the filter")
    option_parser.add_option("-d", "--debug",
        action = "store_true", dest = "debug",
        help = "Enable debug output")
    option_parser.add_option("--backup",
        action = "store_true", dest = "backup",
        help = "Create a backup for each file. This is the default")
    option_parser.add_option("--no-backup",
        action = "store_false", dest = "backup",
        help = "Do not create backups")
    option_parser.add_option("--go",
        action = "store_true", dest = "go",
        help = "Perform changes rather than just printing then")
    option_parser.add_option("--dry-run", "-n",
        action = "store_false", dest = "go",
        help = "Do not change anything. This is the default")
    option_parser.add_option("--color",
        action = "store_false", dest = "color",
        help = "Colorize output. This is the default")
    option_parser.add_option("--no-color",
        action = "store_false", dest = "color",
        help = "Do not colorize output")
    option_parser.add_option("--quiet", "-q",
        action = "store_true", dest = "quiet",
        help = "Do not produce any output")

    option_parser.set_defaults(
        no_hidden = True,
        no_filter = False,
        backup    = True,
        go        = False,
        color     = True,
        debug     = False,
        quiet     = False)

    (opts_obj, args) = option_parser.parse_args()

    opts = vars(opts_obj)

    if not opts.get("color"):
        for k in COLORS.iterkeys():
            COLORS[k] = ""

    if opts.get("debug"):
        logging.basicConfig(level=logging.DEBUG)

    if len(args) < 2:
        print "Wrong number of arguments"
        print __usage__
        sys.exit(2)

    pattern = args[0]
    repl    = args[1]

    regexp = re.compile(pattern)

    def repl_action(f):
        return replace_in_file(opts, f, regexp, repl)

    if len(args) > 3:
        files = args[2:]
        for f in files:
            repl_action(f)
    else:
        recurse_file(opts, os.getcwd(), repl_action)



if __name__ == "__main__":
    main()


